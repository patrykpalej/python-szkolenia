### 6.1 Procedura
Często zdarza się, że pewien fragment kodu wykonujemy wielokrotnie w trakcie działania programu. Może on służyć do wykonania określonej operacji - na przykład obliczenia odległości między dwoma (dowolnymi) punktami albo zapisu jakiejś treści do pliku tekstowego. Zamiast wielokrotnie się powtarzać, możemy takie zadanie okodować jeden raz, umieścić je w tzw. funkcji i odwoływać się do niej za każdym razem, kiedy chcemy wykonać to zadanie. Jest to bardzo powszechne w programowaniu.

Jednym z rodzajów funkcji jest procedura. To taka funkcja, która *niczego nie zwraca* a jedynie *wykonuje zestaw operacji*. O funkcjach zwracających wartość będzie więcej [[6. Funkcje#6.3 Słowo kluczowe return|poniżej]].

Jednym z zadań, które jest powtarzalne w symulacji starcia między ludźmi a zombie może być strzał oddany przez człowieka do zombie. Uproszczony model takiego strzału znajduje się poniżej:
```python
def shoot_zombie():
    print("AAAAOOOUUAA!!! <gunshot>  ...")
```

Definicja funkcji składa się z kilku elementów składowych. Na początku mamy słowo kluczowe `def`, które oznacza że definiujemy funkcję. Następnie znajduje się nazwa funkcji oraz para nawiasów okrągłych a na końcu dwukropek. To co zostanie napisane poniżej we wciętym bloku kodu to ciało funkcji, czyli zestaw instrukcji, które będą wykonane podczas *wywołania funkcji*. Aby wywołać funkcję w dowolnym miejscu w kodzie należy napisać jej nazwę wraz z parą nawiasów okrągłych.

Poniżej przykłady kilku podobnych funkcji wraz z wywołaniem  - tym razem strzelamy kolejno do kilku zombie:
```python
def shoot_two_zombies():
    for z in range(2):
        print("AAAAOOOUUAA!!! <gunshot>  ...")

shoot_two_zombies()


# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
```


```python
def shoot_three_zombies():
    for z in range(3):
        print("AAAAOOOUUAA!!! <gunshot>  ...")

shoot_three_zombies()


# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
```


```python
def shoot_five_zombies():
    for z in range(5):
        print("AAAAOOOUUAA!!! <gunshot>  ...")

shoot_five_zombies()


# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
```

**Procedura - podsumowanie:**
- Aby nie kopiować tego samego kodu za każdym razem kiedy chcemy z niego skorzystać może zamknąć go w funkcji i wywoływać ją w różnych miejscach
- Funkcja, która nie zwraca żadnej wartości to procedura
---
---
---
&nbsp;
### 6.2 Parametry funkcji
W powyższych przykładach zostało napisanych kilka funkcji, które są do siebie bardzo podobne - różnią się tylko jednym szczegółem (liczbą strzałów) ale poza tym ich działanie jest identyczne. Zamiast tworzyć wszystkie te funkcje osobno wystarczy zdefiniować jedną a następnie dodać jeden lub więcej *parametrów*, które pozwolą doprecyzować szczegóły działania funkcji. Parametry podajemy wewnątrz nawiasów w definicji funkcji. Jeśli jest ich więcej niż jeden należy oddzielić je przecinkiem.
```python
def shoot_zombie():
    print("AAAAOOOUUAA!!! <gunshot>  ...")


def shoot_n_zombies(n):
    for z in range(n):
        shoot_zombie()


shoot_n_zombies(3)


# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
# AAAAOOOUUAA!!! <gunshot>  ...
```

Teraz wywołując funkcję `shoot_n_zombies` wystarczyć przekazać do niej *argument*, którego wartość wpłynie na jej działanie.

---
> Parametry to część definicji funkcji, znajdują się wewnątrz nawiasów okrągłych. Argumenty to wartości, które przekazujemy do funkcji w trakcie jej wywołania
---

**Parametry funkcji - podsumowanie:**
- Funkcja może (ale nie musi) posiadać jeden lub więcej parametrów
- Parametry zachowują się jak zmienne, które istnieją tylko wewnątrz funkcji
- Podczas wywoływania funkcji posiadającej parametry musimy przekazać do niej argumenty, czyli wartości przypisane do poszczególnych parametrów
---
---
---
&nbsp;
### 6.3 Słowo kluczowe return
Wiele funkcji nie tylko wykonuje określone instrukcje, ale również *zwraca* jedną lub więcej wartości. Oznacza to, że pewne wartości obecne wewnątrz funkcji mogą zostać przechwycone po jej wywołaniu i użyte już poza funkcją. Poniżej prosty przykład:

```python
def return_true():
    return True


x = return_true()
print(x)

# True
```

Słowo kluczowe `return` poprzedza wartości zwracane przez funkcję. Zazwyczaj znajduje się ono na samym końcu funkcji. Nie jest to wymagane, ale kiedy dotrzemy w kodzie do tego miejsca następuje wyjście z funkcji.

Poniżej kolejny przykład:
```python
def square_a_number(x):
    result = x ** 2
    return result
    print("Ten kod się nie wykona")


square = square_a_number(2)
print(square)

# 4
```


Aby zwrócić kilka wartości należy podać je oddzielone przecinkiem po  `return`. Funkcja zwróci wówczas tuplę tych wartości.
```python
def solve_quadratic_equation(a, b, c):
    delta = b**2 - 4*a*c
    
    x1 = (-b-delta**0.5)/(2*a)
    x2 = (-b+delta**0.5)/(2*a)
    
    return x1, x2

solve_quadratic_equation(1, 1, -2)

# (-2.0, 1.0)
```


Poniżej ten sam przykład, ale z wyodrębnieniem zadania liczenia delty do oddzielnej funkcji. Dobrą praktyką jest stosowanie się do *zasady pojedynczej odpowiedzialności.* Oznacza ona, że każda funkcja powinna wykonywać tylko jedno zadanie. Poszczególne mniejsze zadania wyodrębniamy do osobnych funkcji. 
```python
def calculate_delta(a, b, c):
    return b**2 - 4*a*c


def solve_quadratic_equation(a, b, c):
    delta = calculate_delta(a, b, c)
    
    x1 = (-b-delta**0.5)/(2*a)
    x2 = (-b+delta**0.5)/(2*a)
    
    return x1, x2


x1, x2 = solve_quadratic_equation(1, 1, -2)
print(x1)
print(x2)


# -2.0
# 1.0
```


**Słowo kluczowe return - podsumowanie:**
- Aby funkcja zwróciła jedną lub więcej wartości używamy słowa kluczowego `return`. Zwracane wartości będą mogły być użyte również poza funkcją
- Użycie `return` kończy działanie funkcji. Najczęściej dzieje się to na samym końcu ciała funkcji
- Aby zwrócić kilka wartości należy podać je po przecinku
---
---
---
&nbsp;
### 6.4 Parametry z wartością domyślną
Niektóre parametry mogą mieć wartość domyślną. Oznacza to, że jeśli nie przekażemy niczego w postaci argumentu, zostanie użyta domyślna wartość. Definiujemy ją w następujący sposób:
```python
def calculate_distance_to_point(coordinates, reference=(0, 0)):
    x_a, y_a = coordinates
    x_b, y_b = reference
    
    return ( (x_a - x_b)**2 + (y_a - y_b)**2 )**0.5


calculate_distance_to_point((2, 2))
# 2.8284271247461903

calculate_distance_to_point((2, 2), (0, 0))
# 2.8284271247461903

calculate_distance_to_point((2, 2), (1, 1))
# 1.4142135623730951
```

Powyższa funkcja oblicza i zwraca odległość między dwoma punktami (tuplami) o współrzędnych x,y. Jeśli nie przekażemy do niej drugiego punktu (*reference*) to zostanie użyty tam punkt (0, 0). Jeśli przekażemy inną wartość - to ona będzie wykorzystana.

**Parametry z wartością domyślną - podsumowanie:**
- Parametr funkcji może mieć wartość domyślną - definiujemy ją w deklaracji funkcji
- Takie parametry muszą być zadeklarowane *po* tych bez wartości domyślnej
- Jeśli przekażemy jako argument inną wartość, zostanie ona użyta
---
---
---
&nbsp;
### 6.5 Wbudowane generatory cz. 2
#### 6.5.1 `map`
Funkcje mogą zostać użyte do **zmapowania** jednej sekwencji na drugą. Używamy w tym celu generatora `map`. Na początek definicja prostej funkcji oraz listy.
```python
def add_one(x):
    return x + 1

list_of_numbers = [1, 3, 4, 6, 6, 9]
```
Aby zmapować `list_of_numbers` za pomocą funkcji `add_one` - czyli utworzyć taką sekwencję, że każdy jej element otrzymujemy poprzez zastosowanie danej funkcji na kolejnych elementach listy - piszemy następujący kod:
```python
map(add_one, list_of_numbers)

# <map at 0x7f461426a0d0>
```

Jego rezultatem jest obiekt typu `map`, który po zrzutowaniu na `list` daje taką listę:
```python
list(map(add_one, list_of_numbers))

# [2, 4, 5, 7, 7, 10]
```

Obiekt typu `map` jest iterablą a więc możemy po nim iterować.

#### 6.5.2 `filter`
Aby przefiltrować sekwencję pod kątem spełnienia przez jej elementy danego warunku logicznego można użyć generatora `filter`. Należy w tym celu napisać funkcję, która będzie przyjmować jeden argument i zwracać wartość logiczną *True/False*:

```python
def is_even(x):
    return x % 2 == 0

filter(is_even, list_of_numbers)
# <filter at 0x7f46142c6be0>

list(filter(is_even, list_of_numbers))
# [4, 6, 6]
```

Obiekt typu `filter` jest iterablą a więc możemy po nim iterować.

**Wbudowane generatory cz. 2 - podsumowanie:**
- Aby zmapować sekwencję używając dowolnej funkcji używamy generatora `map`
- Aby przefiltrować sekwencję uzywając funkcji, która zwraca wartość logiczną używamy generatora `filter`
- Obiekty typów `map` i `filter` są iterablami
---
---
---
&nbsp;
### 6.6 lambda
Generatory z powyższych przykładów jako jeden z argumentów przyjmują funkcję. Gdyby ta funkcja miała być wykorzystana tylko raz - w celu zmapowania lub przefiltrowania listy - może się okazać że zamiast ją definiować w klasyczny sposób wygodniej będzie skorzystać z *lambdy*. 

Lambda to skrócony sposób zapisu funkcji, która musi być na tyle krótka że zwracane wyrażenie może być zapisane w jednej linijce. Funkcja służąca do mnożenia podanej wartości przez 3 wygląda następująco:
```python
lambda x: 3*x
```

Po słowie kluczowym `lambda` deklarujemy jeden lub więcej parametr. Następnie - po dwukropku - znajduje się zwracana wartość. 

Taką funkcję możemy utworzyć jak zwykły obiekt - przypisując do zmiennej - a następnie wywołać. Zwykle jednak tego nie robimy. Inne określenie na lambdę to "funkcja anonimowa" co oznacza że nie ma ona nazwy, a jedynie przekazujemy ją jako argument do innej funkcji. 

Tak wygląda przekazanie lambdy do `map` oraz `filter`:
```python
list_of_numbers = [1, 3, 4, 6, 6, 9]


list(map(lambda x: x + 1, list_of_numbers))
# [2, 4, 5, 7, 7, 10]


list(filter(lambda x: x % 2 == 0, list_of_numbers))
# [4, 6, 6]
```

**Lambda - podsumowanie:**
- Kiedy chcemy przekazać funkcję jako argument dla innej funkcji możemy użyć lambdy zamiast definiować i nazywać ją jako obiekt
- Lambda posiada jeden lub więcej parametrów (po przecinku). To co znajduje się po dwukropku jest zwracane 
---
---
---
&nbsp;
### 6.7 arguments unpacking

---
---
---
&nbsp;
### 6.8 args, kwargs

---
---
---
&nbsp;
### 6.9 Kolejność parametrów

---
---
---
&nbsp;
### 6.10 Docstring i doctest

---
---
---
&nbsp;
### 6.11 Zakres przestrzeni nazw

---
---
---
&nbsp;
