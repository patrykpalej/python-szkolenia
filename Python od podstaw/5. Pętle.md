### 5.1 Pętla for
#### 5.1.1 Funkcja `range`
Przed rozpoczęciem nauki pisania pętli w Pythonie dobrze jest poznać wbudowaną funkcję `range`.   Zwraca ona zestaw wartości, które nie pojawiają się w pamięci programu jednocześnie (tak jak np. w przypadku list) ale możemy dostać się do nich po kolei. Dzięki temu optymalizujemy zużycie pamięci. Aby stworzyć zakres wartości od 0 do 6 posłużymy się poniższym kodem:

```python
range(0, 6)

# range(0, 6)
```

Ponieważ wartości z tego zakresu nie trafiają do pamięci jednocześnie to output powyższej linii kodu nie wyświetla ich wszystkich. Wie jednak jaka jest ich sekwencja i w razie potrzeby będziemy mogli się do nich po kolei dostać. 

Jeżeli do funkcji `range` przekażemy tylko jeden argument - tak jak poniżej - zostanie on potraktowany jako wartość maksymalna przedziału natomiast wartością minimalną będzie 0:

```python
range(6)

# range(0, 6)
```

Możemy oczywiście wstawić jako pierwszą i ostatnią wartość zakresu dowolną wartość. Ich kolejność powinna być rosnąca, w przeciwnym wypadku `range` nie zwróci nam żadnych wartości:

```python
range(3, 9)

# range(3, 9)
```

Aby zobaczyć jakie wartości zawiera `range` można zrzutować go na listę:
```python
list(range(3, 9))

# [3, 4, 5, 6, 7, 8]


list(range(4))

# [0, 1, 2, 3]
```
Jak widać ostatnia wartość zakresu nie wchodzi do niego - przedział jest otwarty. Podobnie jak przy slicingu.

Jeśli chcemy żeby wartości w `range` rosły nie co 1 ale z innym krokiem, należy tę wartość przekazać jako trzeci argument:

```python
list(range(0, 6, 2))

# [0, 2, 4]
```


#### 5.1.2 Idea pętli
Często zdarza się że pewien fragment kodu chcemy wykonać wielokrotnie. Rozważmy symulację, w której w kolejnych krokach czasowych dzieją się określone akcje - np. postacie się poruszają albo walczą. Gdybyśmy chcieli zaimplementować to bez użycia pętli wyglądałoby to mniej więcej tak:

```python
print("Iteracja 1\n")

print("Postacie się poruszają")
print("Postacie walczą\n\n")

# ---

print("Iteracja 2\n")

print("Postacie się poruszają")
print("Postacie walczą\n\n")

# ---

print("Iteracja 3\n")

print("Postacie się poruszają")
print("Postacie walczą\n\n"
```

Każda iteracja (tura) wymagałaby ponownego napisania tego samego kodu. Poza tym jeśli iteracji byłoby kilkadziesiąt, kilkaset czy kilka tysięcy to tego kodu byłoby bardzo dużo. Zresztą wcale nie musimy z góry wiedzieć ile iteracji będzie miała symulacja.

Do tego właśnie służą pętle - aby określony kawałek kodu wykonać wielokrotnie ale napisać go tylko raz. Jest to bardzo często wykorzystywany element sterowania przepływem programu. W Pythonie istnieją dwa rodzaje pętli spośród których częściej spotykaną jest pętla `for`. Używamy jej kiedy **wiemy z góry ile razy kod ma się wykonać**. W tej pętli istnieje specjalna zmienna - tzw. **iterator** - która w każdej iteracji przyjmuje określoną wartość. Powyższy kod przepisany z użyciem pętli `for` wyglądałby następująco:

```python
for i in range(3):
    print(f"Iteracja {i+1}\n")

    print("Postacie się poruszają")
    print("Postacie walczą\n\n")
```

Iteratorem tej pętli jest zmienna `i` (często używamy takiej nazwy). W kolejnych iteracjach będzie ona przyjmować kolejne wartości z range'a `range(3)` czyli: 0, 1, 2. Wewnątrz każdej iteracji printujemy informację o jej numerze porządkowym (kolejno 1, 2, 3) a następnie wykonujemy określone akcje takie jak poruszanie się czy walka postaci. Należy pamiętać o **wcięciu oraz dwukropku**, które są elementami składni pętli.

Dobrą praktyką jest nieposługiwanie się w kodzie liczbami, których znaczenie nie jest oczywiste, tak jak w powyższym przykładzie liczba 3 w `range`. Są to tzw. *magic numbers*. Należy takie wartości zapisać do zmiennej i odpowiednio nazwać:
```python
n_of_iterations = 3

for i in range(n_of_iterations):
    print(f"Iteracja {i+1}\n")

    print("Postacie się poruszają")
    print("Postacie walczą\n\n")
```

#### 5.1.3 Iterowanie po liście
Bardzo często można zobaczyć pętlę `for`, która przechodzi po kolejnych elementach jakiejś kolekcji, zazwyczaj listy. Wówczas wartość iteratora w kolejnych iteracjach to kolejne elementy tej kolekcji:

```python
for item in [1, 2, 3, 4]:
    print(item)

# 1
# 2
# 3
# 4
```

```python
numbers = [1, 2, 3, 4]

for n in numbers:
    if n % 2 ＝＝ 0:
        print(f"Liczba {n} jest parzysta")
    else:
        print(f"Liczba {n} jest nieparzysta")

# Liczba 1 jest nieparzysta
# Liczba 2 jest parzysta
# Liczba 3 jest nieparzysta
# Liczba 4 jest parzysta
```

#### 5.1.4 Iterowanie po słowniku
Możemy również iterować po słowniku. Wówczas iterator przyjmuje takie wartości jak klucze tego słownika:

```python
human_dict = {"x": 1, "y": -4, "velocity": 5, "power": 8, "experience": 4}

for feature in human_dict:
    print(f"Feature: {feature}, value: {human_dict[feature]}")

# Feature: x, value: 1
# Feature: y, value: -4
# Feature: velocity, value: 5
# Feature: power, value: 8
# Feature: experience, value: 4
```

Jeśli chcemy dostać się zarówno do klucza jak i wartości możemy użyć funkcji `items()` oraz użyć **dwóch iteratorów**:

```python
human_dict = {"x": 1, "y": -4, "velocity": 5, "power": 8, "experience": 4}

for feature, value in human_dict.items():
    print(f"Feature: {feature}, value: {value}")
```

#### 5.1.5 Instrukcja `pass`
Może się zdarzyć, że tymczasowo chcemy aby w ciele pętli (czyli tym co znajduje się we wciętym bloku) nie było żadnego kodu. Brak ciała pętli spowoduje błąd programu, ale możemy to obejść za pomocą instrukcji `pass`, która znaczy tyle co "nie rób niczego":

```python
for i in range(6):
    pass
```
W powyższym przykładzie iterator przejdzie po wszystkich wartościach z range'a, ale nic poza tym się nie wydarzy.

---
**Pętla `for` - podsumowanie:**
- Funkcja `range` zwraca zakres wartości od-do rosnących o określoną wartość (krok)
- Wartości zwrócone przez `range` nie trafiają do pamięci na raz lecz jedna po drugiej, dopiero kiedy to sprowokujemy
- Aby wykonać dany blok kodu określoną liczbę razy należy użyć pętli `for`
- Pętla `for` posiada **iterator** czyli zmienną, która w każdej iteracji posiada inną wartość. W pewnych przypadkach iteratorów może być więcej niż jeden
- Możemy iterować po listach, słownikach czy innych strukturach danych
- Aby nie wykonywać w pętli żadnych instrukcji należy umieścić tam instrukcję `pass`
---
---
---
&nbsp;
### 5.2 Pętla while
Oprócz pętli `for` w Pythonie mamy do dyspozycji również pętlę `while`. Wykonuje się ona tak długo jak spełniony będzie zadany w niej warunek logiczny. W poniższym przykładzie warunkiem wykonywania się pętli jest to, że zmienna `i` jest większa od 0. W każdej iteracji printujemy tę zmienną oraz dekrementujemy ją. Tym samym po czterech iteracjach warunek `i > 0` przestaje być spełniany `==` i pętla przestaje działać.
```python
i = 4

while i > 0:
    print(i)
    i -= 1

# 4
# 3
# 2
# 1
```


```python
```


```python
```



```python
```


```python
```
---
---
---
&nbsp;
### 5.3 Instrukcje break oraz continue

---
---
---
&nbsp;
### 5.4 Zagnieżdżone pętle

---
---
---
&nbsp;
### 5.5 zip i enumerate w pętli for

---
---
---
&nbsp;
### 5.6 list comprehension

---
---
---
&nbsp;
