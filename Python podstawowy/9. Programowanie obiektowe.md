### 9.1 Klasa oraz obiekt
Kiedy pisany przez nas kod się rozrasta, coraz trudniej jest utrzymać go w stanie możliwym do modyfikacji i utrzymywania. Liczba zmiennych i funkcji staje się większa a zależności między nimi są coraz trudniejsze do uchwycenia. Rozwiązaniem tego problemu może być wykorzystanie paradygmatu obiektowego.

Programowanie zorientowane obiektowo (ang. _Object oriented programming_) to podejście do pisania kodu, które zakłada, że poszczególne funkcjonalności zostają zamknięte w tzw. klasach czyli mniejszych, niezależnych częściach. Klasa zawiera opis wszystkich własności oraz działań, jakie możemy wykonywać na jej przedstawicielach. Dodatkowo klasy pozwalają używać ujednoliconego interfejsu odnoszenia się do poszczególnych jej części składowych.

Klasy mogą symulować rzeczywisty świat, ale mogą również opisywać byty abstrakcyjne, np. typ *int* czy *string.*

Przedstawiciela klasy nazywamy jej instancją albo obiektem. Każdy obiekt może mieć określone wartości przypisane do swoich atrybutów czyli czegoś w rodzaju zmiennych specyficznych dla danej klasy. Możemy na nim również wywoływać funkcje specyficzne dla klasy, czyli metody.


---
---
---
&nbsp;
### 9.2 Definicja klasy, konstruktor, atrybuty
#### 9.2.1 Przykłady klas wbudowanych

**String**
Klasa - *str*
Obiekt - dowolny string
Przykładowe metody: `.lower()`, `.upper()`, `.capitalize()`

**Lista**
Klasa - *list*
Obiekt - dowolna lista
Przykładowe metody: `.append()`, `.extend()`, `.count()`

#### 9.2.2 Klasy definiowane przez nas

Załóżmy, że ludzie i zombie to obiekty, które możemy zamodelować zestawem 5 parametrów:
- współrzędna x
- współrzędna y
- szybkość
- siła
- liczba zabitych / zainfekowanych przeciwników

Tak wyglądać może schemat klasy `Human`. Wymienione są jej atrybuty (czyli cechy, własności) oraz metody (operacje, jakie możemy wykonać na instancji klasy). Poniżej mamy klka obiektów, których atrybuty mają określoną wartość.


![[klasahuman.png]]


Analogiczny przykład dla klasy `Zombie` wygląda następująco:

![[klasazombie.png]]

Takie podejście pozwala na zamodelowanie każdej postaci przez jeden obiekt zamiast używania *n* zmiennych czy słownika + zestawu niezależnych funkcji. Skutkuje to większą przejrzystością i porządkiem w projekcie. Do każdego atrybutu czy metody obiektu możemy dostać się z poziomu tego obiektu, podobnie jak dostajemy się do metody `append()` z poziomu listy, którą chcemy zmodyfikować:
```python
my_list = [1, 2, 3]
my_list.append(4)
```

---
Implementacja powyższych klas w Pythonie została opisana poniżej. Na razie ograniczymy się wyłącznie do atrybutów, które definiujemy w specjalnej metodzie inicjalizacyjnej. Metody **choose_new_position( )** oraz **move( )** zostały na razie pominięte.

```python
class Human:
    def __init__(self, x, y, velo, power, n_killed=0):
        self.x = x
        self.y = y
        self.velocity = velo  # nazwy parametru funkcji __init__ i atrybutu mogą się różnić
        self.power = power
        self.n_killed = n_killed
```

Zaczynamy od słowa kluczowego `class` po którym następuje nazwa klasy. Powinna ona być napisana z wielkiej litery - po tym poznajemy, że coś jest klasą. Następnie wcięty blok kodu zaczynamy od metody \_\_init__(), która będzie wykonana po utworzeniu obiektu. Jej lista parametrów zaczyna się od *self*, który jest odniesieniem do obiektu tej klasy. Co ważne, nie jest to żaden konkretny obiekt. *self* odnosi się zawsze do tego obiektu, który aktualnie jest tworzony w \_\_init__(). Pozostałe parametry działają jak w każdej innej funkcji.

Wewnątrz metody \_\_init__() przypisujemy do poszczególnych atrybutów klasy `Human` wartości pochodzące z przekazanych argumentów. W podobny sposób utworzymy klasę `Zombie`:

```python
class Zombie:
    def __init__(self, x, y, velo, power, n_inf=0):
        self.x = x  
        self.y = y
        self.velocity = velo
        self.power = power
        self.n_infected = n_inf
```

W dalszej kolejności utworzymy instancje tych klas poprzez odwołanie się do nazwy klasy jak do funkcji i przekazanie jej jako argumentów tych wartości, których oczekuje \_\_init__() (nie wliczając *self*). 

```python
initial_x = 8.53
initial_y = -3.23
velocity = 4
power = 8

human = Human(initial_x, initial_y, velocity, power)
```

Teraz po odwołaniu się do poszczególnych atrybutów zobaczymy te wartości, które zostały przekazane w trakcie tworzenia obiektu:

```python
print(human.x)
print(human.y)
print(human.velocity)
print(human.power)
print(human.n_killed)

# 8.53
# -3.23
# 4
# 8
# 0
```

To samo robimy dla `Zombie`. Tym razem, dla urozmaicenia,  przekazujemy wartości wprost, bez tworzenia wcześniej zmiennych. To również jest dopuszczalne.

```python
zombie = Zombie(1, 2, 3, 4)

print(zombie.x)
print(zombie.y)
print(zombie.velocity)
print(zombie.power)
print(zombie.n_infected)

# 1
# 2
# 3
# 4
# 0
```


**Definicja klasy, konstruktor, atrybuty - podsumowanie:**
- Klasa to abstrakcyjny opis zawierający zbiór atrybutów (własności) oraz metod (funkcji) używanych do modelowania obiektów tej klasy
- W Pythonie istnieją klasy wbudowane (np. *str*, *int*, *float*, ...) ale możemy tworzyć również własne. Wówczas ich nazwa powinna zaczynać się od wielkiej litery
- Klasy prawie zawsze posiadają metodę inicjalizacyjną, która zawiera zestaw instrukcji jakie zostają wykonane po utworzeniu obiektu. Przede wszystkim są tam przypisywane wartości do atrybutów
- Aby odwołać się do atrybutu obiektu należy użyć zapisu `<object_name>.<attribute_name>`
---
---
---
&nbsp;
### 9.3 Metody

---
---
---
&nbsp;
### 9.4 staticmethod, classmethod

---
---
---
&nbsp;
### 9.5 Dziedziczenie

---
---
---
&nbsp;
### 9.6 Stringifikacja i reprezentacja

---
---
---
&nbsp;
### 9.7 class attribute

---
---
---
&nbsp;
